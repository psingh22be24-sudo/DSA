#include <iostream>
#include <vector>
#include <queue>
using namespace std;

typedef pair<int, pair<int,int>> node; 
// (cost, (x,y))

int dijkstraGrid(vector<vector<int>>& grid) {
    int m = grid.size();
    int n = grid[0].size();

    // Directions: right, left, down, up
    int dx[4] = {0, 0, 1, -1};
    int dy[4] = {1, -1, 0, 0};

    // Distance matrix initialized to large values
    vector<vector<int>> dist(m, vector<int>(n, 1e9));

    // Min-heap priority queue
    priority_queue<node, vector<node>, greater<node>> pq;

    // Start at (0,0)
    dist[0][0] = grid[0][0];
    pq.push({grid[0][0], {0, 0}});

    while (!pq.empty()) {
        auto curr = pq.top();
        pq.pop();

        int cost = curr.first;
        int x = curr.second.first;
        int y = curr.second.second;

        // If reached bottom-right
        if (x == m-1 && y == n-1)
            return cost;

        // Explore neighbors
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i];
            int ny = y + dy[i];

            if (nx >= 0 && ny >= 0 && nx < m && ny < n) {
                int newCost = cost + grid[nx][ny];

                if (newCost < dist[nx][ny]) {
                    dist[nx][ny] = newCost;
                    pq.push({newCost, {nx, ny}});
                }
            }
        }
    }

    return dist[m-1][n-1];
}

int main() {
    vector<vector<int>> grid = {
        {1, 2, 3},
        {4, 5, 6},
        {7, 8, 9}
    };

    cout << dijkstraGrid(grid) << endl;
    return 0;
}
